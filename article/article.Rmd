---
documentclass: jss
classoption: shortnames
title:
  formatted: "\\pkg{bayesnec}: An R Package for C-R Modelling and Estimation of toxicity metrics"
  # If you use tex in the formatted title, also supply version without
  plain:     "bayesnec: An R Package for C-R Modelling and Estimation of No-Effect-Concentrations"
  # For running headers, if needed
  short:     "\\pkg{bayesnec}: An R Package for C-R Modelling"
author:
  - name: Rebecca Fisher
    address:
      - Australian Institute of Marine Science,
      - Crawley, WA, Australia
    address2:
      - The Indian Ocean Marine Research Centre,
      - University of Western Australia,
      - Crawley, WA, Australia
    affiliation:
      'Australian Institute of Marine Science'
    affiliation2:
      'University of Western Australia'
    email: \email{r.fisher@aims.gov.au}
    orcid: 0000-0001-5148-6731
  - name: Diego R. Barneche
    address:
      - Australian Institute of Marine Science,
      - Crawley, WA, Australia
    address2:
      - The Indian Ocean Marine Research Centre University of Western Australia,
      - Crawley, WA, Australia
    affiliation: 'Australian Institute of Marine Science'
    affiliation2: 'University of Western Australia'
    orcid: 0000-0002-4568-2362
  - name: Gerard Ricardo
    address:
      - The University of Queensland,
      - St Lucia, Qld, Australia
    address2:
      - Australian Institute of Marine Science,
      - Townsville, Qld, Australia
    affiliation: 'University of Queensland'
    affiliation2:
      'Australian Institute of Marine Science'
    orcid: 0000-0002-7761-0806
  - name: David Fox
    address:
      - Environmetrics Australia,
      - Beaumaris, Victoria, Australia
    address2:
      - University of Melbourne     
      - Parkville, Victoria, Australia      
    affiliation: 'Environmetrics Australia'
    affiliation2:
      'University of Melbourne'
    orcid: 0000-0002-3178-7243
abstract: >
  The \pkg{bayesnec} package has been developed for R to fit concentration(dose) - response curves (C-R) to toxicity data for the purpose of deriving no-effect-concentration (*NEC*), no-significant-effect-concentration (*NSEC*), and effect-concentration (of specified percentage 'x', *EC~x~*) thresholds from non-linear models fitted using Bayesian Hamiltonian Monte Carlo (HMC) via \pkg{brms} [@Burkner2017; @Burkner2018] and \pkg{rstan} [@rstan2021] or \pkg{cmdstanr} [@cmdstanr2022]. In \pkg{bayesnec} it is possible to fit a single model, custom models-set, specific model-set or all of the available models. When multiple models are specified the `bnec` function returns a model weighted average estimate of predicted posterior values. A range of support functions and methods are also included to work with the returned single, or multi-model objects that allow extraction of raw, or model averaged predicted, *NEC*, *NSEC* and *EC~x~* values and to interrogate the fitted model or model-set. The statistical methods used mean that the uncertainty in derived threshold values can be robustly quantified, including uncertainty in individual model fits to the underlying observed data, as well as uncertainty in the model functional form.
keywords:
  # at least one keyword must be supplied
  formatted: [concentration-response, toxicity, no-effect-concentration, "\\proglang{R}", Bayesian, non-linear modelling]
  plain:     [concentration-response, toxicity, no-effect-concentration, R, Bayesian, non-linear modelling]
preamble: |
  \usepackage{amsmath}
  \usepackage{float}
bibliography: article.bib
output:
  bookdown::pdf_book:
    base_format: rticles::jss_article
df_print: kable
---

```{r setup, include=FALSE}
library(bayesnec)
library(cmdstanr)
options(prompt = 'R> ', continue = '+ ')
knitr::opts_chunk$set(purl = TRUE, warning = FALSE, message = FALSE, echo = TRUE, cache = TRUE, include = TRUE, eval = TRUE, fig.align = "center", fig.pos = "!ht")
options(brms.backend = "cmdstanr")
```

# Introduction

Concentration-response (C-R) modelling (also known as dose-response modelling or dose-response analysis) is a key tool for assessing toxicity and deriving the toxicity thresholds used in the risk assessments that underpin protection of human health and the environment. It is widely used in the disciplines of pharmacology, toxicology and ecotoxicology, where parametric non-linear regression methods are used to model response data of interest, with the resulting fitted models used to estimate critical thresholds of concern. These thresholds may be used directly to assess risk [e.g see @fisher2018c], or are subsequently incorporated into a broader population-level risk assessment framework [e.g. @Warne2015]. Typical thresholds derived from C-R modelling include the effect-concentration of defined percentage 'x' (ECx) and the no-effect-concentration (NEC), the latter being the generally preferred option [@Fox2008; @Warne2015; @Warne2018c].

In qualitative terms, C-R models are a decreasing function of concentration, whereby the response may remain relatively stable for the initial portion of the curve, and then decays at some rate to zero (or some other lower bound at high concentration). An example is death of an organism resulting from ever increasing concentrations of a toxic pollutant. However, often the underlying mechanisms describing C-R relationships are not known, and therefore numerous alternative non-linear C-R equations have been proposed. These can be broadly grouped into two main "model categories" (see below Section \ref{mdbnc}) for the mathematical definition of each model): *NEC* models---threshold models which contain a step function comprising the "break-point" after which the predictor systematically alters the response [@Fox2010]; and Smooth transition models that are typically used for estimating effect concentrations of a specified effect (e.g. *EC~x~*- models). They may or may not encompass the EC~50~ as a parameter [@Ritz2016]. Each of these two groups can be further split into two categories depending on whether the initial portion of the curve is flat, or increasing---the latter being known as hormesis models [@Ritz2016].

The above model categories mostly comprise non-linear equations, thereby increasing the technical complexity of model fitting. C-R experimental designs are often also complex, and may require the addition of multi-level, hierarchical effects. Examples might include a random offset to model non-independence of replicates housed together in tanks, or where there are repeated measurements on individual genotypes of a test species. Additionally, C-R data are of varied nature, with the measured response data taking a wide range of natural distributions. For instance, response data may be unbounded continuous (e.g. growth when shrinkage is possible), or positive continuous (e.g. growth in the absence of shrinkage), proportional (e.g. fertilization success), or binary (e.g. survival). To the best of our knowledge, there is no open-source statistical software dedicated to C-R modelling which allows for appropriate model and error distribution specification depending on the input data. However, there is a wide array of multi-purpose packages for fitting non-linear generalised hierarchical models in R. For example (to list a few), \pkg{nlme} [@pinheiro2021], \pkg{lme4} [@pinheiro2021], \pkg{rjags} [@Su2015] and \pkg{rstan} [@rstan2021].

While C-R modelling can be carried out using generic non-linear modelling software packages, this can be cumbersome in practice, requiring extensive manual programming to obtain the necessary, often relatively standard outputs. The \pkg{drc} package [@Ritz2016] was developed as a user friendly Frequentist based solution to C-R modelling in R, and is currently widely used across a range of disciplines. \pkg{drc} implements a broad range of non-linear C-R models, provides facilities for ranking model fits based on AIC [@Burnham2002], joint modelling of multiple response curves, and supports a range of estimation procedures [@Ritz2016]. Section \ref{bnchmrk} provides a formal comparison between \pkg{drc} and \pkg{bayesnec} standard output using default argument values.

Estimates of uncertainty in parameters and derived thresholds are critical for effective integration of threshold estimates into risk assessment and formal decision frameworks [@fisher2018c]. Bayesian methods allow robust quantification of uncertainty with intuitive and direct probabilistic meaning [@Ellison1996], and are therefore an excellent platform for C-R modelling in most settings. Furthermore, the posterior draws generated through Bayesian model fitting methods provide a rich resource that can be used to explore synergistic and antagonistic impacts [@Fisher2019d; @flores2021], propagate endpoint uncertainty [@Charles2020a; @Gottschalk2013], and test hypotheses of no-effect [@Thomas2006].

There is a wide array of packages available for Bayesian model fitting via Markov chain Monte Carlo methods, including WinBUGS [@Lunn2000], JAGS [@Plummer2003] and Stan [@Carpenter2017], that seamlessly interface with R through packages such as \pkg{R2WinBUGS}, \pkg{R2jags} [@Su2015] and \pkg{rstan} [@rstan2021]. These packages require coding in R and additional model specification in custom languages---which might involve non trivial coding, extensive debugging and optimisation that is often time consuming and requires specialist expertise. All of which might add a learning/application barrier to many potential users. Several extension packages which aim to reduce that barrier have recently become available, principally \pkg{brms} [@Burkner2017], that allows a broad range of models to be easily fitted using \pkg{rstan}[@rstan2021] or \pkg{cmdstanr} [@cmdstanr2022] through simpler \pkg{lme4}-like formula syntax. However, even with packages like \pkg{brms}, Bayesian model fitting can be difficult to automate across all potential usage cases, particularly with respect to specifying valid initial parameter values and appropriate priors. In addition, as was the motivation for the development of the \pkg{drc} package in the frequentist setting, the R code required for fitting non-linear models and extracting the relevant outputs (e.g. *NEC*, *EC~x~*) and their standard errors can be cumbersome in practice, and even more so in the Bayesian setting where model fits contain multiple posterior draws.

The greater complexity associated with Bayesian model fitting has likely hindered the uptake of Bayesian statistics for C-R threshold derivation across the broader ecotoxicology and toxicology communities, who may not have access to specialist statistical expertise [@Fisher2019]. \pkg{bayesnec} version `r packageVersion("bayesnec")` (available on CRAN) builds upon an implementation of the *NEC* model described in [@Fox2010; @Pires2002]. The \pkg{bayesnec} package provides an accessible interface specifically for fitting *NEC* and *EC~x~* and other C-R models using Bayesian methods. A variety of models can be specified based on the known distribution of the "concentration" or "dose" variable (the predictor, x) as well as the "response" (y) variable. The model formula, including priors and initial values required to call \pkg{brms} are automatically generated based on information contained in the supplied data. A range of tools is supplied to aid the user in interrogating model fits, plotting and generating predicted values, as well as extracting the standard outputs, such as *NEC* and *EC~x~* - either as a full posterior draw or in summary form.

# Technical details

In Bayesian inference, model parameters and their inherent uncertainty are estimated as statistical probability distributions. This is achieved by combining an a-priori probability distribution for each parameter (the 'priors', $p(\theta)$) with the likelihood of the observed data, $D$, given the model parameters, $p(D | \theta)$, to yield a so-called posterior probability distribution, $p(\theta | D)$

\begin{equation}
  p(\theta | D) = \frac{p(D | \theta) p(\theta)}{\int_{\theta} p(D | \theta) p(\theta) d \theta} \propto p(D | \theta) p(\theta).
  \label{eqn1}
\end{equation}

In many cases, the denominator (a.k.a. "evidence" or "marginal") is analytically intractable, and therefore we resort to numerical approximations such as Markov Chain Monte Carlo (MCMC). \pkg{bayesnec} uses the extensive functionality of the \pkg{brms} package to write model code as well as fit models via a Stan program [@stan2021], which typically defines a Bayesian posterior as a log density function conditioned on the data. Stan employs Hamiltonian Monte Carlo (HMC)---a type of MCMC algorithm---for its fitting mechanism, and automatically optimizes the discretization time parameter to match an acceptance-rate target using the no-U-turn sampling (NUTS) algorithm [@hoffman2014]. \pkg{bayesnec} first takes the input model or model-set (via its custom formula class, `bayesnecformula`) in conjunction with potential user-defined hierarchical effects, to generate an object of class `brmsformula`. Then, based on the package-(or user-)specified priors, and response model distribution, it calls \pkg{brms} [@Burkner2017; @Burkner2018] to generate the Stan program code and fit the model through either \pkg{rstan} [@rstan2021] or \pkg{cmdstanr}[@cmdstanr2022]. In doing so, \pkg{bayesnec} (as of version `r packageVersion("bayesnec")`) allows for response variables to be modelled with a variety of statistical distributions: Gaussian, Poisson, Binomial, Gamma, Negative-binomial, Beta and Beta-binomial. Future implementations of \pkg{bayesnec} might include additional distributions which are currently only implemented in \pkg{brms}. In addition to greater flexibility in the available response distributions, \pkg{bayesnec} includes a larger set of 23 *NEC*- and *EC~x~*- models (see below), including many of the commonly-used models in \pkg{drc} [@Ritz2016].
  
## Models in \pkg{bayesnec} {short-title="Models in bayesnec" #mdbnc}

Where possible we have aimed for consistency in the interpretable meaning of the individual parameters across models. Across the currently implemented model sets, models contain from two (basic linear or exponential decay, see **ecxlin** or **ecxexp**) to five possible parameters (**nechorme4**), including:

$\tau = \text{top}$, usually interpretable as either the response's intercept or the upper plateau representing the mean concentration of the response at zero concentration;

$\eta = \text{NEC}$, the No-Effect-Concentration value (the concentration value where the breakpoint in the regression is);

$\beta = \text{beta}$, generally the exponential decay rate of response, either from 0 concentration or from the estimated $\eta$ value, with the exception of the **neclinhorme** model where it represents a linear decay from $\eta$ because slope ($\alpha$) is required for the linear increase (see below);

$\delta = \text{bottom}$, representing the lower asymptotic response at infinite concentration;

$\alpha = \text{slope}$, the linear decay rate in the models **neclin** and **ecxlin**, or the linear increase rate prior to $\eta$ for all hormesis models;

$\omega$ = $\text{EC\textsubscript{50}}$, notionally the 50% effect concentration but may be influenced by scaling and should therefore not be strictly interpreted as such, 

$\epsilon = \text{d}$, the exponent in the **ecxsigm** and **necisgm** models, and

$\zeta = \text{f}$ A scaling exponent exclusive to model **ecxll5**.

In addition to the model parameters, all **nec**- models have a step (indicator) function used to define the breakpoint in the regression, which can be defined as

$$
I(x_i, \eta) = \begin{cases} 
      0, & x_i - \eta < 0 \\
      1, & x_i - \eta \geq 0 \\
   \end{cases}
$$


Note that strictly positive parameters (for example, $\beta$ and $\epsilon$) have been transformed as exponential functions to allow the use of normal priors and stabilize model fitting.

### \textit{EC\textsubscript{x}} models {short-title="ECx models" #ecx-models}

#### ecxlin
is a basic linear decay model, given by the equation:
$y_i = \tau - e^{\alpha} x_i$
with the following `brmsformula`: \texttt{`r as.character(show_params("ecxlin")[[1]][[1]])`}. Because the model contains linear predictors it is not suitable for 0, 1-bounded data (i.e. Binomial and Beta families with an `"identity"` link function). As the model includes a linear decline with concentration, it is also not suitable for 0 bounded data (Gamma, Poisson, Negative Binomial with an `"identity"` link).

#### ecxexp
is a basic exponential decay model, given by the equation: $y_i = \tau e^{-e^{\beta} x_i}$
with the following `brmsformula`: `r as.character(show_params("ecxexp")[[1]][[1]])`. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function.

#### ecxsigm 
is a simple sigmoidal decay model, given by the equation:
$y_i = \tau e^{-e^{\beta} x_i^{e^\epsilon}}$
with the following `brmsformula`: `r as.character(show_params("ecxsigm")[[1]][[1]])`. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function.

#### ecx4param
is a 4-parameter sigmoidal decay model, given by the equation:
$y_i = \tau + (\delta - \tau)/(1 + e^{e^{\beta} (\omega - x_i)})$
with the following `brmsformula`: `r as.character(show_params("ecx4param")[[1]][[1]])`


#### ecxwb1
is a 4-parameter sigmoidal decay model which is a slight reformulation of the Weibull1 model of @Ritz2016, given by the equation:
$y_i = \delta + (\tau - \delta) e^{-e^{e^{\beta} (x_i - \omega)}}$
with the following `brmsformula`: `r as.character(show_params("ecxwb1")[[1]][[1]])`

#### ecxwb1p3
is a 3-parameter sigmoidal decay model which is a slight reformulation of the Weibull1 model of @Ritz2016, given by the equation:
$y_i = {0} + (\tau - {0}) e^{-e^{e^{\beta} (x_i - \omega)}}$
with the following `brmsformula`: `r as.character(show_params("ecxwb1p3")[[1]][[1]])`. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function.

#### ecxwb2
is a 4-parameter sigmoidal decay model which is a slight reformulation of the Weibull2 model of @Ritz2016, given by the equation:
$y_i = \delta + (\tau - \delta) (1 - e^{-e^{e^{\beta} (x_i - \omega)}})$
with the following `brmsformula`: `r as.character(show_params("ecxwb2")[[1]][[1]])`. While very similar to the **ecxwb1** [according to @Ritz2016], fitted **ecxwb1** and **ecxwb2** models can differ slightly.

#### ecxwb2p3
is a 3-parameter sigmoidal decay model, which is a slight reformulation of the Weibull2 model of @Ritz2016, given by the equation:
$y_i = {0} + (\tau -{0}) (1 - e^{-e^{e^{\beta} (x_i - \omega)}})$
with the following `brmsformula`: `r as.character(show_params("ecxwb2p3")[[1]][[1]])`. While very similar to the **ecxwb1p3** [according to @Ritz2016], fitted **ecxwb1p3** and **ecxwb2p3** models can differ slightly. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a logit or log link function.

#### ecxll5
is a 5-parameter sigmoidal log-logistic decay model, which is a slight reformulation of the LL.5 model of @Ritz2016, given by the equation:
$y_i = \delta + (\tau - \delta) / (1 + e^{-e^{\beta} (x_i - \omega)})^{e^\zeta}$
with the following `brmsformula`: `r as.character(show_params("ecxll5")[[1]][[1]])`.

#### ecxll4
is a 4-parameter sigmoidal log-logistic decay model which is a slight reformulation of the LL.4 model of @Ritz2016, given by the equation:
$y_i = \delta + (\tau - \delta)/ (1 + e^{e^{\beta} (x_i - \omega)})$
with the following `brmsformula`: `r as.character(show_params("ecxll4")[[1]][[1]])`.

#### ecxll3
is a 3-parameter sigmoidal log-logistic decay model, which is a slight reformulation of the LL.3 model of @Ritz2016, given by the equation:
$y_i = 0 + (\tau - 0)/ (1 + e^{e^{\beta} (x_i - \omega)})$
with the following `brmsformula`: `r as.character(show_params("ecxll3")[[1]][[1]])`. 
The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function.

#### ecxhormebc5
is a 5 parameter log-logistic model modified to accommodate a non-linear hormesis at low concentrations. It has been modified from to the "Brain-Cousens" (BC.5) model of @Ritz2016, given by the equation:
$y_i = \delta + (\tau - \delta + e^{\alpha} x)/ (1 + e^{e^{\beta} (x_i - \omega)})$
with the following `brmsformula`: `r as.character(show_params("ecxhormebc5")[[1]][[1]])`.

#### ecxhormebc4
is a 5-parameter log-logistic model similar to the **exchormebc5** model but with a lower bound of 0, given by the equation:
$y_i = 0 + (\tau - 0 + e^{\alpha} x)/ (1 + e^{e^{\beta} (x_i - \omega)})$
with the following `brmsformula`: `r as.character(show_params("ecxhormebc4")[[1]][[1]])`. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1\textwidth]{../vignettes/vignette-fig-exmp2b-theoretical_ecx_curves.png}
  \caption{Representative shapes of currently implemented \pkg{bayesnec} \textit{EC\textsubscript{x}} models.}
  \label{fig1}
\end{figure}

\newpage

### \textit{NEC} models {short-title="NEC models" #nec-models}

#### neclin
is a basic linear decay model equivalent to **ecxlin** with the addition of the *NEC* step function, given by the equation:
$y_i = \tau - e^{\alpha} \left(x_i - \eta \right) I(x_i, \eta)$
with the following `brmsformula`: `r as.character(show_params("neclin")[[1]][[1]])`. Because the model contains linear predictors it is not suitable for 0, 1-bounded data (Binomial and Beta distributions with `"identity"` link). As the model includes a linear decline with concentration, it is also not suitable for 0, `Inf` bounded data (Gamma, Poisson, Negative Binomial with `"identity"` link).

#### nec3param
is a basic exponential decay model equivalent to **ecxexp** with the addition of the *NEC* step function, given by the equation:
$y_i = \tau e^{-e^{\beta} \left(x_i - \eta \right) I(x_i, \eta)}$
with the following `brmsformula`: `r as.character(show_params("nec3param")[[1]][[1]])`. For Binomial-distributed response data in the case of `"identity"` link this model is equivalent to that in @Fox2010. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function.

#### nec4param
is a 3-parameter decay model with the addition of the *NEC* step function, given by the equation:
$y_i = \delta + (\tau - \delta) e^{-e^{\beta} \left(x_i - \eta \right) f(x_i, \eta)}$
with the following `brmsformula`: `r as.character(show_params("nec4param")[[1]][[1]])`.

#### nechorme
is a basic exponential decay model with an *NEC* step function equivalent to **nec3param**, with the addition of a linear increase prior to $\eta$, given by the equation
$y_i = (\tau + e^{\alpha} x_i) e^{-e^{\beta} \left(x_i - \eta \right) I(x_i, \eta)}$
with the following `brmsformula`: `r as.character(show_params("nechorme")[[1]][[1]])`. The **nechorme** model is a *hormesis* model [@Mattson2008], allowing an initial increase in the response variable at concentrations below $\eta$. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function. In this case the linear version (**neclinhorme**) should be used.

#### nechormepwr
is a basic exponential decay model with an *NEC* step function equivalent to **nec3param**, with the addition of a power increase prior to $\eta$, given by the equation:
$y_i = (\tau + x_i^{1/(1+e^{\alpha})}) e^{-e^{\beta} \left(x_i - \eta \right) I(x_i, \eta)}$
with the following `brmsformula`: `r as.character(show_params("nechormepwr")[[1]][[1]])`. The **nechormepwr** model is a *hormesis* model [@Mattson2008], allowing an initial increase in the response variable at concentrations below $\eta$. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function. Because the model can generate predictions > 1 it should not be used for Binomial and Beta distributions with `"identity"` link. In this case the **nechromepwr01** model should be used.

#### neclinhorme
is a basic linear decay model with an *NEC* step function equivalent to **neclin**, with the addition of a linear increase prior to $\eta$, given by the equation:
$y_i = (\tau + e^{\alpha} x_i) - e^{\beta} \left(x_i - \eta \right) I(x_i, \eta)$
with the following `brmsformula`: `r as.character(show_params("neclinhorme")[[1]][[1]])`.  The **neclinhorme** model is a *hormesis* model [@Mattson2008], allowing an initial increase in the response variable at concentrations below $\eta$. This model contains linear predictors and is not suitable for 0, 1-bounded data (Binomial and Beta distributions with `"identity"` link). As the model includes a linear decline with concentration, it is also not suitable for 0, `Inf` bounded data (Gamma, Poisson, Negative Binomial with `"identity"` link).

#### nechorme4
is 4 parameter decay model with an *NEC* step function equivalent to **nec4param** with the addition of a linear increase prior to $\eta$, given by the equation:
$y_i = \delta + ((\tau + e^{\alpha} x_i) - \delta ) e^{-e^{\beta} \left(x_i - \eta \right) I(x_i, \eta)}$
with the following `brmsformula`: `r as.character(show_params("nechorme4")[[1]][[1]])`. The **nechorme4** model is a *hormesis* model [@Mattson2008], allowing an initial increase in the response variable at concentrations below $\eta$.

#### nechorme4pwr
is 4 parameter decay model with an *NEC* step function equivalent to **nec4param** with the addition of a power increase prior to $\eta$, given by the equation:
$y_i = \delta + ((\tau + x_i^{1/(1+e^{\alpha})}) - \delta) e^{-e^{\beta} \left(x_i - \eta \right) I(x_i, \eta)}$
with the following `brmsformula`: `r as.character(show_params("nechorme4pwr")[[1]][[1]])`. The **nechorme4pwr** model is a *hormesis* model [@Mattson2008], allowing an initial power increase in the response variable at concentrations below $\eta$. Because the model can generate predictions > 1 it should not be used for Binomial and Beta distributions with `"identity"` link. In this case the **nechromepwr01** model should be used.

#### nechormepwr01
is a basic exponential decay model with an *NEC* step function equivalent to **nec3param**, with the addition of a power increase prior to $\eta$, given by the equation:
$y_i = \left(\frac{1}{(1 + ((1/\tau)-1)  e^{-e^{\alpha}x_i}}\right) e^{-e^{\beta} \left(x_i - \eta \right) I(x_i, \eta)}$
with the following `brmsformula`: `r as.character(show_params("nechormepwr01")[[1]][[1]])`. The **nechormepwr01** model is a *hormesis* model [@Mattson2008], allowing an initial increase in the response variable at concentrations below $\eta$. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function. In this case the linear version (**neclinhorme**) should be used.

#### necsigm
is a basic exponential decay model equivalent to **ecxlin** with the addition of the *NEC* step function, given by the equation:
$y_i = \tau e^{-e^{\beta} ((x_i - \eta) f(x_i, \eta))^{e^\epsilon}I(x_i, \eta)}$
with the following `brmsformula`: `r as.character(show_params("necsigm")[[1]][[1]])`. The model is 0-bounded, thus not suitable for Gaussian response data or the use of a `"logit"` or `"log"` link function. Estimation of No-Effect-Concentrations using this model are not currently recommended without further testing, as the behaviour is currently unstable.


\begin{figure}[ht]
  \centering
  \includegraphics[width=1\textwidth]{../vignettes/vignette-fig-exmp2b-theoretical_nec_curves.png}
  \caption{Representative shapes of currently implemented \pkg{bayesnec} \textit{NEC} models.}
  \label{fig2}
\end{figure}


\newpage

## Priors on model parameters

To undertake a Bayesian analysis, prior probability densities of the parameters of the model must first be defined. Sometimes there may be substantial prior knowledge, for example when pilot data or data from a previous experiment exist for a given response curve. In this case the prior probability distribution may be quite narrow (highly "informative") and will therefore be influential in the characterisation of the posterior, especially when subsequent data are scarce or highly variable. However, in our experience in ecology and related disciplines, such prior knowledge is generally the exception. Where no quantitative prior information exists, it is common in Bayesian statistics to use "vague" or "weakly" informative priors. The use of "vague", "diffuse", "flat" or otherwise so-called "uninformative" priors is no longer recommended [@Banner2020]. Such priors generally form the default for many Bayesian packages, and are often used in practice without critical thought or evaluation, possibly as a result of fear of being too subjective [@Banner2020]. However, even vague priors can have a substantial influence on the outcome of an analysis [@depaoli2020importance; @gelman2017entropy]. Instead, it is better to use weakly informative, "generative" priors - that is priors that are based on probability distributions that interact sensibly with the likelihood to produce a meaningful data generating mechanism [@gelman2017entropy].

Considerable thought has gone into development of an algorithm to build "weakly" informative priors for fitting models in \pkg{bayesnec}. The priors are "weakly" informative in that in addition to specifying the relevant statistical family that appropriately captures the parameter's theoretical statistical distribution, we also use information contained within the observed data to centre the probability density near the most likely parameter space and/or constrain priors to sensible bounds. These weakly informative priors are used to help constrain the underlying routines so that they are less likely to consider what the researcher would deem highly improbable estimates, that may also cause the routines to become unstable. Weakly informative priors can be particularly helpful in complex non-linear modelling to ensure reliable convergence. These types of priors specify the general shape and bounds of the probability distribution for a given parameter, whilst remaining sufficiently broad so as not to influence the parameter's estimated posterior distribution (given a reasonable amount of observed data). In this sense, appropriately weak priors should yield analytical outcomes that share the same level of *objectivity* as equivalent Frequentist approaches, whilst yielding robust parameter estimates with probabilistically interpretable uncertainty bounds. Note, however that it is critical for users to critically interrogate these default priors, using for example, sensitivity analysis [@depaoli2020importance] and ensure they are appropriate given the data [@gelman2017entropy].

### Priors for response-scaled parameters

Only the parameters $\tau = \text{top}$ and $\delta = \text{bottom}$ relate directly to the response variable's distribution. For Gaussian-distributed responses (or any response variable for which the link ensures valid values of the response can take from -$\infty$ to $\infty$, including `log` and `logit`) priors are Gaussian with a mean set at the 90^th^ and 10^th^ quantiles of the response for parameters $\tau = \text{top}$ and $\delta = \text{bottom}$, respectively, and a standard deviation of 2.5 * the standard deviation of the response (on the appropriate link scale). In this way \pkg{bayesnec} attempts to construct a prior that scales appropriately with the observed data, with greatest density near the most likely region of the response for both $\tau = \text{top}$ and $\delta = \text{bottom}$. By setting the standard deviation of the prior at 2.5 times the observed standard deviation of the response, these priors should be very broad and have little influence on each parameter's posterior density.

For Poisson-, Negative-binomial- and Gamma-distributed response variables, the response cannot take negative values and therefore Gaussian priors are unsuitable. Instead, we use Gamma priors with a mean scaled to correspond to the 75^th^ and 25^th^ quantiles of the response for $\tau = \text{top}$ and $\delta = \text{bottom}$, respectively. The mean ($\mu$) is linked mathematically to the shape (s) and rate parameters (r) by the equation $$ \mu = s * (1/r) $$ [@Becker1988] with the shape parameter being set to 2 by default. The value of 2 was selected based on trial and error through initial testing, as this appeared to produce relatively broad priors that were still centered around feasible values for these parameters.

For the Binomial, Beta, and Beta-binomial families, estimates for $\tau = \text{top}$ and $\delta = \text{bottom}$ must necessarily be constrained between 0 and 1 when modelled on the identity link. Because of this constraint, there is no need to adjust scaling based on the response. In this case \pkg{bayesnec} uses `beta(5, 2)` and `beta(2, 5)` priors to provide a broad density centred across the upper and lower 0 to 1 range for the $\tau = \text{top}$ and $\delta = \text{bottom}$ parameters respectively.

### Priors for predictor-scaled parameters

The parameters $\eta = \text{NEC}$ and $\eta = \text{ec50}$ scale according to the predictor variable because both of these are estimated in units of the predictor (usually concentration). To stabilise model fitting, the $\eta = \text{NEC}$ and $\eta = \text{ec50}$ parameters are bounded to the upper and lower observed range in the predictor, under the assumption that the range of concentrations in the experiment were sufficient to cover the full range of the response outcomes. Note that this assumption may not always hold if the data are from an experiment that is badly designed, and the outcome of any analysis resulting in either $\eta$ or $\eta$ being estimated at the bounds of the predictor data range should be interpreted with caution. The priors used reflect the characteristics of the observed data that are used to predict the appropriate family. If the predictor variable is strictly positive, a Gamma prior is used, with maximum density ($\mu$, see above) at the median value of the predictor, and a shape parameter of 5. If the predictor variable is truncated at both 0 and 1, a `beta(2, 2)` prior is used. For predictor variables ranging from -$\infty$ to $\infty$, a Gaussian prior is used, with a mean set at the median of the predictor values and a standard deviation of 2.5 time the standard deviation of the predictor variable.

### Priors for other parameters

For the parameters $\beta = \text{beta}$, $\alpha = \text{slope}$ and $\epsilon = \text{d}$ we first ensured any relevant transformations in the model formula such that theoretical values with the range -$\infty$ to $\infty$ are allowable, and a `normal(0, 5)` (location and scale) prior is used. For example in the `nec3param` model, $\beta = \text{beta}$ is an exponential decay parameter, which must by definition be bounded to 0 and $\infty$. Calling `exp(beta)` in the model formula ensures the exponent meets these requirements. Note also that a mean of 0 and standard deviation of 5 represents a relatively broad prior on this exponential scaling, so this is usually a weakly informative prior in practice.

## Model averaging {short-title="Model averaging" #modavg}

Multi-model inference can be useful where there are a range of plausible models that could be used [@Burnham2002] and has been recently adopted in ecotoxicology for Species Sensitivity Distribution (SSD) model inference [@Thorley2018; @fox2020; @Dalgarno]. The approach may have considerable value in C-R modelling because there is often no a priori knowledge of the functional form that the response relationship should take. In this case, model averaging can be a useful way of allowing the data to drive the model selection process, with weights proportional to how well the individual models fit the data. Well-fitting models will have high weights, dominating the model averaged outcome. Conversely, poorly fitting models will have very low model weights and will therefore have little influence on the outcome. Where multiple models fit the data equally well, these can equally influence the outcome, and the resultant posterior predictions reflect that model uncertainty.

\pkg{bayesnec} adopts the weighting methods implemented in the \pkg{loo} package in R [@vehtari2020]. \pkg{loo} provides an efficient approximate leave-one-out cross-validation (LOO) algorithm for Bayesian models fit using Markov chain Monte Carlo, as described in [@vehtari2017] <doi:10.1007/s11222-016-9696-4>. The approximation uses Pareto smoothed importance sampling (PSIS), a new procedure for regularizing importance weights and follows the implementation described in [@Vehtari2019]. The \pkg{loo} package offers two weighting methods, the "stacking" method, aimed to minimise prediction error [@Yao2018], and the "pseudobma" method, with and without Bayesian bootstrap [@vehtari2020; @vehtari2017]. The stacking method (method="stacking"), combines all models by maximizing the leave-one-out predictive density of the combination distribution, such that it finds the optimal linear combining weights for maximizing the leave-one-out log score [@vehtari2020]. The pseudo-BMA method (method="pseudobma") finds the relative weights proportional to the theoretical expected log pointwise predictive density of each model [@vehtari2020]. The Bayesian bootstrap (when using method="pseudobma") takes into account the uncertainty of finite data points and regularizes the weights away from the extremes of 0 and 1 [@vehtari2020]. \pkg{bayesnec} currently uses by default the "pseudobma" method (method = "pseudobma") with Bayesian bootstrap (BB = TRUE), but this can be easily modified via argument "loo_controls".

# Usage

## The fitting function \emph{bnec} {short-title="The fitting function bnec" #ffbnec}

The main working function in \pkg{bayesnec} is `bnec`. We have attempted to make the `bnec` function as easy to use as possible, targeting the R user that is familiar with the usual model fitting syntax in R, but without specialist expertise in non-linear modelling and Bayesian statistics. We can run `bnec` by supplying the argument `formula`: a special custom formula which comprises the relationship between response and predictor, and the C-R model (or models) chosen to be fitted; and `data`: a `data.frame` containing the data for the model fitting.

## The input formula

In its simplest syntax, the basic `bnec` formula should be of the form:

```{r syntax, eval = FALSE}
response ~ crf(predictor, model = "a_model")
```

where the left-hand side of the formula is implemented exactly as in \pkg{brms} (see the 'aterms' Section of the `brms::brm`'s help file). The right-hand side of the formula contains the special internal function `crf` (which stands for concentration-response function), and takes the predictor (including any simple function transformations such as `log`) and the desired C-R model or suite of models. As with any formula in R, the name of the terms need to be exactly as they are in the input data.frame. For Binomial- or Beta-Binomial distributed data, the user needs to include the `trials` term to the left-hand side of the formula, e.g.

```{r formula, eval = FALSE}
response | trials(n_trials) ~ crf(log(predictor), model = "a_model")
```

The input formula can either be a character string or a validated object of class `bayesnecformula`. Details about existing possibilities are detailed in the help files of `bayesnecformula` and `check_formula`. The argument `model` in the formula function `crf` is a character string indicating the name(s) of the desired model(s). Alternatively, it may also be one of `"all"`, meaning all of the available models will be fit; `"ecx"` meaning only models excluding the $\eta = \text{NEC}$ step parameter will be fit; `"nec"` meaning only models with a specific $\eta = \text{NEC}$ step parameter will be fit; `"bot_free"` meaning only models without a `"bot"` parameter (without a lower plateau) will be fit; `"zero_bounded"` are models that are bounded to be zero; or `"decline"` excludes all hormesis models, i.e., only allows a strict decline in response across the whole predictor range (see above Section \ref{mdbnc}).

The class `bayesnecformula` (generated by the function `bayesnecformula` and its alias `bnf`) contains a `model.frame` method which can be employed to manually inspect the `data.frame` that will be used to run checks on the data suitability prior to model fitting, e.g.

```{r loading}
library(bayesnec)
df <- data.frame(x = rgamma(100, 2, 0.1), y = rnorm(100))
form <- bnf(y ~ crf(log(x), model = "nec3param"))
head(model.frame(form, df))
```

## Example

Here we use one of the package's built-in datasets from @jones2003meps which comprise assays of herbicide phytotoxicity on chlorophyll fluorescence measurements (Fv/Fm) of symbiotic dinoflagellates still in the host tissue of the coral. For detail on this example dataset is provided in Section \ref{iexample}.


```{r example, warning = FALSE, message = FALSE, results = "hide", cache = TRUE}
data(herbicide)
# filter for one herbicide only
data <- herbicide[herbicide$herbicide == "diuron", ]
set.seed(333)
fit <- bnec(fvfm ~ crf(log(concentration), model = "nec4param"), data = data)
```

If a recognized model name is provided, a single model of the specified type is fit, and `bnec` returns an object of class `bayesnecfit`. If a vector of two or more of the available models are supplied, or if one of the model-sets is specified, `bnec` returns a model object of class `bayesmanecfit` containing Bayesian model averaged predictions for the supplied models, providing they were successfully fitted (see \ref{modavg} above, and the help file of `bnec` for further details). By default, `bnec` sets the number of chains to 4, the number of iterations per chain to 10,000, and the size of the warm-up period to 4/5 of the number of iterations (i.e 8,000 by default).

`bnec` will guess the most likely distribution for the response variable. In the example above, the model was fitted assuming a Beta distribution on an identity link because the response is truncated at both 0 and 1. Note that the default behaviour in `bayesnec` is to use the `"identity"` link because the native link functions for each family (e.g., `"logit"` for Binomial, `"log"` for Poisson) introduce non-linear transformation on formulas which are already non-linear. So please be aware that estimates of *NSEC* or *EC~x~* might not be as expected when using link functions other than identity. Additionally, `bnec` will also generate appropriate priors for the internal `brms::brm` model call. However, `bnec` allows the user to pass additional arguments to `brms::brm` and therefore the user can, for example, manually add specific distributions and link functions via the argument `family`, or custom priors via the argument `prior`. Please refer to the rich set of resources available for the \pkg{brms} package at https://github.com/paul-buerkner/brms for further information.

## Classes and methods

Models fitted by `bnec` will invariably inherit a class `bnecfit` which carries three exclusive methods: `+`, `c` and `update`. The first two are used to append one or multiple models to an existing fit, whereas the latter is used to update the fitting characteristics of an existing model (e.g. change the number of iterations or warm-up period, or simply change the HMC fitting parameters). When `bnec` fits a single C-R model type, the output object also inherits the `bayesnecfit` class. This class contains the `brmsfit` object in addition to the mean predicted values, summary estimates of each model parameter, and a full posterior distribution of the *NSEC* estimate. Alternatively, if `bnec` fits a custom set of models, or a package-pre-defined model-set (e.g. `model = "all"` in the input formula), the output object is going to inherit the `bayesmanecfit` class. Differently from a `bayesnecfit` object, `bayesmanecfit` comprises a model weighted estimate of predicted posterior values of *NSEC*.

Both `bayesnecfit` and `bayesmanecfit` classes contain methods for `summary`, `print`, `predict`, `model.frame`, plotting (`plot` and `autoplot`), as well as custom functions for extracting effect concentrations and related threshold values (`nec`, `ecx` and `nsec`) that, in the case of a `bayesmanecfit`, return model weighted estimates.

The `summary` method provides the usual summary of model parameters and any relevant model fit statistics as returned in the underlying `brm` model fit(s). In the specific case of a `bayesmanecfit` object, the summary includes a list of fitted models, their respective model weights, and a model-averaged *NEC*---which is reported with a warning when it contains *NSEC* values (see below Section \ref{modsuit}).

```{r summary, warning = FALSE, message = FALSE}
summary(fit)
```

As mentioned above, the visualization of a particular model fit can be done via either \pkg{base} R (`plot`) and \pkg{ggplot2} (`autoplot`). Here we pass the additional argument `xform` which ensures that the *NEC* estimate is transformed to the proper scale (because the original formula contained `log(concentration)`):

\newpage

```{r base-plot, fig.height = 3.5, fig.width = 4, fig.cap = "\\pkg{ggplot2} `autoplot` of the example fit. The solid black line is the fitted median of the posterior prediction, dashed black lines are the 95\\% credible intervals, and the vertical lines show the estimated \\textit{NEC} value."}
round_digits <- function(x) sprintf("%.2f", x)
autoplot(fit, xform = exp) +
  scale_x_continuous(trans = "log", labels = round_digits)
```

By default the plot shows the fitted posterior curve with 95% credible intervals, along with an estimate of the $\eta = \text{NEC}$ value. Please see on-line the vignettes at https://open-aims.github.io/bayesnec/articles/ for more examples using \pkg{bayesnec} models for inference, as well as Section \ref{modsuit} below.

## Model diagnostics

A range of tools are available to assess model fit, including an estimate of overdispersion (for relevant families), an extension of the \pkg{brms} `rhat` function that can be applied to both `bayesnecfit` and `bayesmanecfit` model objects, and a function `check_chains` that can be used to visually assess chain mixing and stability.

All diagnostic functions available in \pkg{brms} and \pkg{rstan} can be used on the underlying `brm` model fit by extracting the fitted \pkg{brms} model from the `bayenecfit` or `bayesmanecfit` model object using the function `pull_brmsfit`. For example, we can use the default \pkg{brms} plotting method to obtain a diagnostic plot of the individual fit of the **nec4param** model using:


```{r brmsplot, fig.width = 5.14, fig.height = 6, fig.cap = "Default \\pkg{brms} plot of the \\texttt{nec4param} model showing the posterior densities and chain mixing for each of the included parameters.", dependson="fit"}
plot(pull_brmsfit(fit))
```

which yields a plot of the posterior densities as well as trace plots of chains for each parameter in the specified model (\autoref{fig:brmsplot}).

Several helper functions have been included that allow the user to add or drop models from a `bayesmanecfit` object, or change the model weighting method (`amend`); extract a single or subset of models from the `bayesmanecfit` object (`pull_out`); and examine the priors used for model fitting (`pull_prior`, `sample_priors` and `check_priors`).

To ensure a `bnec` fit retains the same level of objectivity as an equivalent frequentist approach we recommend using the function `check_priors` to compare the prior and posterior probability densities and check that the priors used by \pkg{bayesnec} are sensible and are not exerting an undesirable influence over the analysis.

### User-specified priors

In \pkg{bayesnec} we chose to provide default priors that are data-dependent. They were designed to be somewhat informative (relative to each parameter's region) but that would, in data-sufficient cases, return fits without HMC divergent transitions in Stan. Default "blanket" priors are not currently provided for non-linear models by the model-building underlying package \pkg{brms}, and we note that defining the extent to which a prior is vague or weakly/strongly informative ultimately depends on the likelihood [@gelman2017entropy]. Therefore, there may be situations where the default \pkg{bayesnec} priors do not behave as desired, or the user wants to provide customised priors. For example, the default priors may be too informative, yielding unreasonably tight confidence bands (although this is only likely where there are few data or unique values of the predictor variable). Conversely, priors may be too vague, leading to poor model convergence. Alternatively, the default priors may be of the wrong statistical family if there was insufficient information in the provided data for \pkg{bayesnec} to correctly predict the appropriate ones to use. The priors used in the default model fit can be extracted using `pull_prior`, and a sample or plot of prior values can be obtained from the individual \pkg{brms} model fits through the function `sample_priors` which samples directly from the `prior` element in the `brmsfit` object (`sample_priors(fit$fit$prior)`, see \autoref{fig:sampleprior}).

```{r sampleprior, echo=FALSE, fig.height = 3.5, fig.width = 4.5, fig.cap = "Frequency histograms of samples of the default priors used by bnec for fitting the \\texttt{nec4param} model to the example data."}
sample_priors(pull_brmsfit(fit)$prior)
```

We can also use the function `check_priors` (based on the `hypothesis` function of \pkg{brms}) to assess how the posterior probability density for each parameter differs from that of the prior. Here we show the prior and posterior probability densities for the parameters in the `nec4param` model fit (`check_priors(fit)`, see \autoref{fig:checkpriorsingle}). There is also a `bayesmanecfit`-specific method that can be used to sequentially view all plots in a `bnec` call with multiple models, or write to a pdf as in `check_chains`.

```{r checkpriorsingle, echo=FALSE,fig.height = 3.5, fig.width = 6, fig.cap = "A comparison of the prior and posterior parameter probability densities for the \\texttt{nec4param} model fit to the example data."}
check_priors(fit)
```

## Model comparison

With \pkg{bayesnec} we have included a function (`compare_posterior`) that allows bootstrapped comparisons of posterior predictions. This function allows the user to fit several different `bnec` model fits and compare differences in their posterior predictions. Comparisons can be made across the model fits for individual threshold estimates (e.g. *NEC*, *NSEC* or *EC~x~*) or across a range of predictor values. Usage is demonstrated in the relevant vignette at https://open-aims.github.io/bayesnec/articles/example4.html by comparing different types of models and model-sets using a single dataset. However, the intent of this function is to allow comparison across different datasets that might represent, for example, different levels of a fixed factor covariate. For example, this function has been used to compare toxicity of herbicides across three different climate scenarios, to examine the cumulative impacts of pesticides and global warming on corals [@flores2021].

At this time `bnec` does not allow for an inclusion of an interaction with a fixed factor. Including an interaction term within each of the non-linear models implemented in \pkg{bayesnec} is relatively straightforward, and may be introduced in future releases. However, in many cases the functional form of the response may change with different levels of a given factor. The substantial complexity of defining all possible non-linear model combinations at each factor level means it unlikely this could be feasibly implemented in \pkg{bayesnec} in the short term. In the meantime the greatest flexibility in the functional form of individual model fits can be readily obtained using models fitted independently to data within each factor level.

## Hierarchical effects

Most ecotoxicological and toxicology experiments include a range of grouping elements, such as tanks, vials or batches of samples that contain multiple measurements that cannot be considered strictly independent (a.k.a. they are pseudo-replicates). To avoid criticism around potential issues with pseudo-replication, it is often the practice for ecotoxicologists to pool such observations and carry out modelling using, for example, the group mean. Where the number of within group observations varies substantially across groups, this will have the undesirable effect of equally weighting the group means even though some may be based on far fewer observations than others. In addition, there are often instances of ecotoxicology data from multiple experiments or other grouping factors within an experiment (such as genotype) that cover the full range of the predictor variable that cannot be averaged prior to modelling, resulting in the ecotoxicologist either ignoring the potential non-independence, or fitting many independent datasets and subsequently needing to aggregate the threshold estimates. Carrying out multiple fits on separate datasets is undesirable because each fit is based on fewer data and will have greater uncertainty. 

The current version of \pkg{bayesnec} harnesses the powerful modelling flexibility of \pkg{brms} for accommodating hierarchical designs and other forms of non-independence. This is achieved by allowing a list of grouping terms to be added to a `bayesnecformula`, which are then used to generate the underlying `brmsformula` for the \pkg{brms} internal call. Hierarchical effects can be in the form of an offset, which effectively allows different mean response levels across groups, and is achieved by specifying the `ogl` (offset group-level) formula term. Hierarchical effects can also be added to any or all of the (non-)linear parameters in the model by specifying the `pgl` (parameter group-level) formula term. Note that implementing hierarchical effects in a non-linear modelling setting is non-trivial and considerable thought and testing should go into selecting an appropriate hierarchical structure, and potentially suitable priors. Examples of how to implement hierarchical effects in \pkg{bayesnec} can be found on the help file of function `bnf`.

# Existing alternatives {short-title="Existing alternatives" #bnchmrk}

\pkg{bayesnec} is built upon the precursor R package \pkg{jagsNEC} [@fisher2020], which writes and fits C-R models in JAGS [@Plummer2003]. \pkg{bayesnec} was then expanded to include several additional C-R models and further generalised to allow a large range of response variables to be modelled using their appropriate statistical distribution. In addition, \pkg{bayesnec} allows the addition of hierarchical effects (see above). The simpler syntax of \pkg{brms} allows \pkg{bayesnec} to be more easily expanded to include additional response distributions as well as C-R model formula. In addition, \pkg{brms} is well developed and comes with a large range of supporting functions not available to the \pkg{jags} equivalents.

While there are some commercial propriety software packages to support the analysis of toxicity data, such as graphpad (<https://www.graphpad.com>) and ToxCalc (<https://www.tidepool-scientific.com/ToxCalc/ToxCalc.html>), these provide limited flexibility and most importantly do not support fully reproducible analysis in an open-source environment. Ensuring that the raw data from the experiment are available; and that the statistical code and documentation to reproduce the analysis are also available are two major components to a reproducible study [@peng2015]. 

The open-source flexible computing environment R, provides an ideal platform for reproducible analysis of toxicity datasets. The main existing tool in R that is widely used in ecotoxicology and toxicology is the frequentist-based package \pkg{drc} [@Ritz2016]. \pkg{drc} provides a suite of flexible and versatile model fitting and after-fitting functions for the analysis of dose-response data. The package includes a large range of built-in dose-reponse models that are parameterized using a unified structure with a coefficient b denoting the steepness of the dose-response curve, c, d the lower and upper asymptotes or limits of the response, and, for some models, e the effective dose ED50 [@Ritz2016]. Estimation in \pkg{drc} is based on the maximum likelihood principle, which under the assumption of normally distributed response values simplifies to nonlinear least squares. \pkg{bayesnec} provides a Bayesian implementation of many of the non-linear models offered by \pkg{drc}. 

We compared the \pkg{drc} and \pkg{bayesnec} fits for the three parameter no-effect-concentration model implemented in WinBugs by @Fox2010 for two selected herbicides from the data from @jones2003meps. In \pkg{bayesnec} this model is fit with the call `bnec(fvfm ~ crf(log_x, model = "nec3param"), data = .x)`, and in \pkg{drc} using `drm(fvfm ~ log_x, fct = NEC.3(), data = .x)`. The herbicides hexazinone and tebuthiuron were selected specifically for this comparison as visual inspection indicated they should provide a reasonable fit to the [@Fox2010] model as there was some evidence of a threshold effect. For both herbicides, the predicted \pkg{drc} and \pkg{bayesnec} values were nearly identical using the default behaviour of each package (\autoref{fig:drccomparisonplot}).

```{r drccomparison, echo = FALSE, results = "hide"}
library(drc)
library(MASS)
library(corpcor)
library(dplyr)
library(ggdist)
options(mc.cores = parallel::detectCores())

rounded <- function(value, precision = 1) {
  sprintf(paste0("%.", precision, "f"), round(value, precision))
}

nec3param <- function(beta, nec, top, x) {
  top * exp(-beta * (x - nec) * ifelse(x - nec < 0, 0, 1))
}

my_rmvnorm <- function(mu, Sigma) {
  r <- length(mu)
  L <- try(t(chol(Sigma)))
  if (inherits(L, "try-error")) {
    L <- t(chol(Sigma, pivot = TRUE))
  }
  Z <- rnorm(r)
  (L %*% Z + mu)[, 1]
}

ggdrc_data <- function(x) {
  nec_mean_drc <- summary(x)$coefficients["e:(Intercept)", "Estimate"]
  nec_cis_drc <- confint(x)["e:(Intercept)", ]
  drc_nec <- c(`50%` = nec_mean_drc, `2.5%` = nec_cis_drc[["2.5 %"]],
               `97.5%` = nec_cis_drc[["97.5 %"]])
  mod_df <- x$data
  df_x <- data.frame(log_x = seq(min(mod_df$log_x), max(mod_df$log_x),
                     length = 100))
  mu <- coef(x)
  Sigma <- drc:::vcov.drc(x)
  is_pos_def <- corpcor::is.positive.definite(Sigma)
  if (!is_pos_def) {
    Sigma <- corpcor::make.positive.definite(Sigma, tol = 1e-3)
  }
  Y <- matrix(0, 1000, nrow(df_x))
  pars_mv <- MASS::mvrnorm(n = nrow(Y), mu, Sigma)
  for (i in seq_len(nrow(Y))) {
    Y[i, ] <- nec3param(beta = pars_mv[i, 1], nec = pars_mv[i, 3],
                        top = pars_mv[i, 2], df_x$log_x)
  }
  preds <- apply(Y, 2, median_hdci, na.rm = TRUE) %>%
    do.call("rbind.data.frame", args = .) %>%
    dplyr::select(y, ymin, ymax)
  e_df <- data.frame(x_e = c(df_x$log_x, rev(df_x$log_x)),
                     y_e = c(preds$y, rep(NA, nrow(preds))),
                     y_ci = c(preds$ymin, rev(preds$ymax)),
                     x_r = NA, y_r = NA, nec_vals = NA, nec_labs = NA,
                     nec_labs_l = NA, nec_labs_u = NA)
  r_df <- data.frame(x_e = NA, y_e = NA, y_ci = NA,
                     x_r = mod_df$log_x, y_r = mod_df$fvfm, nec_vals = NA,
                     nec_labs = NA, nec_labs_l = NA, nec_labs_u = NA)
  n_df <- data.frame(x_e = NA, y_e = NA, y_ci = NA,
                     x_r = NA, y_r = NA, nec_vals = drc_nec,
                     nec_labs = c(drc_nec[[1]], NA, NA),
                     nec_labs_l = c(drc_nec[[2]], NA, NA),
                     nec_labs_u = c(drc_nec[[3]], NA, NA))
  rbind(e_df, r_df, n_df)
}

df_list <- herbicide %>%
  dplyr::filter(herbicide %in% c("hexazinone", "tebuthiuron")) %>%
  dplyr::mutate(log_x = log(concentration)) %>%
  dplyr::arrange(herbicide, concentration) %>%
  split(f = ~ herbicide)

bnec_list <- purrr::map(
  df_list, ~bnec(formula = fvfm ~ crf(log_x, model = "nec3param"), data = .x)
)
drc_list <- purrr::map(
  df_list, ~drm(formula = fvfm ~ log_x, fct = NEC.3(),
                data = .x)
)

if (!all(names(bnec_list) == names(drc_list))) {
  stop("Incompatible name order.")
}

bnec_plot_data <- purrr::map_dfr(bnec_list, ggbnec_data,  .id = "model") %>%
  dplyr::mutate(source = "bayesnec")
drc_plot_data <- purrr::map_dfr(drc_list, ggdrc_data, .id = "model") %>%
  dplyr::mutate(source = "drc")
plot_data <- rbind(bnec_plot_data, drc_plot_data) %>% 
  dplyr::mutate(nec_labs = as.character(signif(exp(as.numeric(nec_labs)),3)),
                nec_labs_l = as.character(signif(exp(as.numeric(nec_labs_l)),3)),
                nec_labs_u = as.character(signif(exp(as.numeric(nec_labs_u)),3)))

```

```{r drccomparisonplot, echo = FALSE, fig.width = 6, fig.height = 3, fig.cap = "A comparison of the bayesnec and drc model fits and estimated NEC values for the \\texttt{nec3param} model, fit to data on maximum effective quantum yield ($\\Delta F / Fm'$) of symbiotic dinoflagellates (in hospite) in \\textit{Seriatopora hystrix} exposed to elevated hexazinone and tebuthiuron (range 0.3 to 1000 ug per L) for 10 h."}

combine_fits <- function(x) {
  ltys <- rep(rep(c(1, 2, 2), length(unique(x$model))), 2)[-c(36:35)]
  lwds <- rep(rep(c(0.5, 0.2, 0.2), length(unique(x$model))), 2)[-c(36:35)]
  ggplot() +
    geom_polygon(data = x %>% filter(!is.na(y_ci)),
                 mapping = aes(x = x_e, y = y_ci, fill = source),
                 alpha = 0.5, show.legend = FALSE) +
    geom_line(data = x %>% filter(!is.na(y_e)),
              mapping = aes(x = x_e, y = y_e, colour = source),
              linetype = 2, show.legend = FALSE) +
    geom_point(data = x %>% filter(!is.na(y_r)),
               mapping = aes(x = x_r, y = y_r), fill = "grey30",
               shape = 21, show.legend = FALSE) +
    geom_vline(data = x %>% filter(!is.na(nec_vals)),
               mapping = aes(xintercept = nec_vals, colour = source),
               linetype = ltys, lwd = lwds, show.legend = FALSE) +
    geom_text(data = x %>% filter(!is.na(nec_labs), source == "bayesnec"),
              mapping = aes(label = paste0("bayesnec: ", nec_labs, " (",
                                           nec_labs_l, "-",
                                           nec_labs_u, ")")),
              x = Inf, y = Inf, hjust = 0.95, vjust = 1.5, size = 2.75,
              colour = "tomato") +
    geom_text(data = x %>% filter(!is.na(nec_labs), source == "drc"),
              mapping = aes(label = paste0("drc: ", nec_labs, " (",
                                           nec_labs_l, "-",
                                           nec_labs_u, ")")),
              x = Inf, y = Inf, hjust = 0.95, vjust = 4, size = 2.75,
              colour = "skyblue2") +
    coord_cartesian(clip = "off") +
    scale_colour_manual(values = c(bayesnec = "tomato", drc = "skyblue2")) +
    scale_fill_manual(values = c(bayesnec = "tomato", drc = "skyblue2")) +
    ylim(0, 0.8) +
    scale_x_continuous(breaks = log(c(0.08, 0.61, 4.5, 33, 240)), 
                       labels = c("0.08", "0.61", "4.5", "33", "240")) +    
    theme_classic() +
    facet_wrap(~model, scales = "free", ncol = 2) +
    theme(strip.text = element_text(hjust = 0),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          strip.background = element_blank(),
          strip.text.x = element_text(size = 12),
          panel.border = element_rect(colour = NA, fill = NA)) +
    labs(x = expression("Concentration "~"("*mu*"g/L)"),
         y = expression(""*Delta*"F"/"F m'"))
}
combine_fits(plot_data)
```

While \pkg{drc} is an excellent tool for fitting C-R models using frequentist methods and is widely used (@Ritz2016 currently has nearly 2,000 citations), \pkg{bayesnec} provides a Bayesian alternative using similarly simple syntax. The advantages of Bayesian methods in this setting are numerous, and include direct characterisation of parameter uncertainty and posterior predicted samples that provide a valuable resource for model inference (such as comparisons of relative toxicity, see Section \ref{iexample} and \autoref{fig:necplots}). In addition, we have observed that even the use of only weakly informative priors tends to improve the reliability of model fits compared to \pkg{drc}, and this may be true of MLE estimation more generally [@krull2020comparing].

# Illustrative Example {short-title="Illustrative Example" #iexample}

So far we have demonstrated the basic usage of \pkg{bayesnec} and compared the results for a single model fit to \pkg{drc}. Here we work through an illustrative example demonstrating the use of the package for a dataset on herbicide toxicity. The aim here is to indicate the usual workflow and highlight the advantages of model averaging combined with Bayesian methods as a rigorous means of estimating and comparing relative toxicity, and the associated uncertainty. The data we analyse in this example are from @jones2003meps.

## Example Case Study

In our case study, the no-effect-toxicity values of a range of herbicides are first estimated and then their relative toxicity is compared. The response data are the maximum effective quantum yield (${\Delta F / Fm'}$) of symbiotic dinoflagellates still in the host tissue of the coral *Seriatopora hystrix* (in hospite or in vivo). ${\Delta F / Fm'}$ was calculated from Chlorophyll fluorescence parameters measured using a DIVING-PAM chlorophyll fluorometer (Walz) as described in more detail in @jones2003meps and @jones2003effects. The corals were exposed to elevated levels of eight different herbicides (Irgarol 1051, ametryn, diuron, hexazinone, atrazine, simazine, tebuthiuron, ioxynil) at concentrations ranging from 0.3 to 1000 ${\mu g/L}$) for 10 h. Data for ioxynil were excluded from analysis here as this herbicide did not show sufficient response at the maximum concentration. 

## Single herbicide analysis {short-title="Single herbicide" #isingle}

We start by describing the analysis workflow for a single herbicide, ametryn. We first filter ametryn from the larger herbicide data set. The concentration data are log transformed prior to analysis to improve model stability and because this is the natural scaling of the concentration series for these data. As there was little evidence of hormesis (an initial increase in the response at low concentration) in these data (or in the other herbicides, see below \ref{iall}), we used only the `decline` model set as candidate models for the model averaging. Setting `model = "decline"` results in \pkg{bayesnec} attempting to fit a set of `r length(bayesnec::models()$decline)` models, and returning an object of class `bayesmancfit` for the herbicide ametryn.


```{r fullbayesmanec_ametryn, eval=TRUE, echo=FALSE, results = "hide", cache = TRUE}
set.seed(333)
data("herbicide")
ametryn <- herbicide %>%
  dplyr::mutate(concentration = log(concentration)) %>% 
  dplyr::filter(herbicide=="ametryn")
manecfit_ametryn <- bayesnec::bnec(fvfm ~ crf(concentration, 
                                   model = "decline"), 
                                   data = ametryn)
```

```{r fullbayesmanec_ametryn_show, eval=FALSE, echo=TRUE}
data("herbicide")
ametryn <- herbicide %>%
  dplyr::mutate(concentration = log(concentration)) %>% 
  dplyr::filter(herbicide=="ametryn")
manecfit_ametryn <- bayesnec::bnec(fvfm ~ crf(concentration, 
                                   model = "decline"), 
                                   data = ametryn)
```

Other than selecting a model set to use, here we leave all other `bnec` arguments as their default. In this case \pkg{bayesnec} correctly chooses a Beta distribution to use as the family, defaults to the identity link, and drops the models "neclin" and "ecxlin" from the complete list of "decline" models (as these are not appropriate for a zero bounded distribution, such as the Beta distribution, \ref{mdbnc}). Note that in this example (or the one below, \ref{iall}) we do not show all of the console output and messages generated by both the `bnec` and underlying `brm` functions, because across `r length(bayesnec::models()$decline)` models this results in substantial output.

Following model fitting, the quality of the fits should be examined using the function `check_chains`, as well as `check_priors` to ensure there is good chain mixing and that the default priors were suitable. The results from these checks are omitted here for brevity, but can be easily saved to pdf output for visual inspection and inclusion into any analysis supplementary material by setting the argument `filename` to any non empty string, as in the code below:

```{r check_chains, eval=TRUE}
check_chains(manecfit_ametryn, filename = "ametryn_check_chains")
check_priors(manecfit_ametryn, filename = "ametryn_check_priors")
```

We can also check the `rhat` values of the fitted models using the `rhat` function:

```{r rhat, eval=FALSE}
rhat(manecfit_ametryn)
```

Once we are happy with the model fits, we can examine the model statistics using `summary`:

```{r manec_summary, dependson = "fullbayesmanecgoodfits"}
summary(manecfit_ametryn)
```

For a `bayesmanecfit` object with multiple model fits, `summary` first displays the class, the family and links that have been used for the model fits, the number of posterior draws contained within each model fit, and a table of the model weights for each model. For the amatryn data set, weights are spread among several **ecx** models, with a small amount of weight for the two **nec** models (*nec3param* and *nec4parm*).

Because \pkg{bayesnec} was primarily developed for estimating no-effect-concentrations, an estimate of model averaged NEC is also provided, in this case with a note that the weighted model averaged estimate contains NSEC values in the case of the fitted *ECx* models. In units of log concentration, the estimated no-effect toxicity value for ametryn is `r manecfit_ametryn$w_nec["Estimate"]`, which is equivalent to `r signif(exp(manecfit_ametryn$w_nec), 3)["Estimate"]` ${\mu}gL^{-1}$. The 95% credible intervals are also provided, based on the 0.025 and 97.5 quantiles of the weighed pooled posterior sample.

Finally, Bayesian $R^2$ estimates are also provided [@gelman2019], as an indicator of overall model fit. This is useful because model weights are always relative to the models actually included in the model set for the given data. The $R^2$ provides an indicator of model fit that can be compared objectively across data sets as an indication of the quality of the fit of any of the supplied models to the data.

We can plot all the models contained within the `bayesmanecfit` using the `autplot` function, with all_models = TRUE (\autoref{fig:fullbayesmanecplotametrynALLplot}):

```{r fullbayesmanec_ametrynALL_code, eval=FALSE, echo=TRUE}
ametryn_plot_all <- autoplot(manecfit_ametryn, all_models = TRUE)
```

We can also plot the model averaged fit that is used to derive the model averaged no-effect-concentration for ametryn, as displayed in the summary (\autoref{fig:fullbayesmanecplotametrynplot}):

```{r fullbayesmanec_ametryn_code, eval=FALSE, echo=TRUE}
ametryn_plot <- autoplot(manecfit_ametryn)
```

```{r fullbayesmanecplotametrynALLplot, echo = FALSE, fig.width = 6, fig.height = 8, fig.cap = "Individual model fits to the ametryn dataset, showing the estimated no effect concentration for each. Data are the maximum effective quantum yield ($\\Delta F / Fm'$) of symbiotic dinoflagellates (in hospite) in \\textit{Seriatopora hystrix} exposed to elevated ametryn (range 0.3 to 1000 ug per L) for 10 h. N(SEC) values presented are model averaged posterior densities of the NEC parameter obtained from all fitted \\texttt{NEC} models, and the NSEC values estimated from all smooth \\texttt{ECx} models."}
ametryn_plot_all <- autoplot(manecfit_ametryn, all_models = TRUE)
ametryn_plot_all +
  ylab(expression(""*Delta*"F"/"F m'")) +
  xlab(expression("Concentration "~"("*mu*"g/L)"))
```

```{r fullbayesmanecplotametrynplot, echo = FALSE, fig.width = 6, fig.height = 3, fig.cap = "Full model averaged bayesmanecfit to the ametryn dataset, showing the estimated model-averaged no effect concentration. Data are the maximum effective quantum yield ($\\Delta F / Fm'$) of symbiotic dinoflagellates (in hospite) in \\textit{Seriatopora hystrix} exposed to elevated ametryn (range 0.3 to 1000 ug per L) for 10 h. N(SEC) values presented are model averaged posterior densities of the NEC parameter obtained from all fitted \\texttt{NEC} models, and the NSEC values estimated from all smooth \\texttt{ECx} models. Only the \\texttt{decline} model set was used (ie. hormesis models were excluded)."}
ametryn_plot <- autoplot(manecfit_ametryn)
ametryn_plot +
  ylab(expression(""*Delta*"F"/"F m'")) +
  xlab(expression("Concentration "~"("*mu*"g/L)"))
```


## Comparing toxicity across herbicides  {short-title="Comparing toxicity" #iall}

Above we describe the workflow for a single herbicide. We now show how to use the same workflow across all herbicides to generate full `bayesmanecfit` model averaged fits and no-effect-toxicity estimates, and use this to compare their relative toxicity.

We start by modelling the concentration-response curves for all seven photo toxicity data sets using the \pkg{bayesnec} package using the following code:

```{r fullbayesmanec_show, eval=FALSE, echo=TRUE}
library(dplyr)
library(purrr)
data("herbicide")
manecfit <- herbicide %>%
  dplyr::mutate(concentration = log(concentration)) %>%
  split(f = ~ herbicide) %>%
  purrr::map(function(x) {
    bayesnec::bnec(fvfm ~ crf(concentration, model = "decline"), data = x)
  })
save(manecfit, file = "manecfits.RData")
```

```{r fullbayesmanec, echo = FALSE, results = "hide", cache = TRUE}
set.seed(333)
library(dplyr)
library(purrr)
data("herbicide")
manecfit <- herbicide %>%
  dplyr::mutate(concentration = log(concentration)) %>%
  split(f = ~ herbicide) %>%
  purrr::map(function(x) {
    bayesnec::bnec(fvfm ~ crf(concentration, model = "decline"), data = x)
  })
```

Because we want to run the analysis for all seven herbicides separately we first split the data, then call the `bnec` function for each herbicide using \pkg{purrr}. We use the same settings and default arguments as for our single herbicide example above (ametryn, see \ref{isingle}). Note that fitting a large set of models using Bayesian methods can take some time, and we recommend running the analysis at a convenient time, and saving the resulting output to a .RData file to work with later.

Once we have our list of fitted `bayesmanecfit` objects for each herbicide, can use `rhat` to check that all models fitted successfully for each, and find any models that fail the `rhat` criteria of <1.05 and removing these using the function `amend`. We achieve this across all the herbicides using \pkg{purrr}. As for the single herbicide fit (see \ref{isingle}), we should also check the chains and priors for each fitted model, although we have skipped that step here.

```{r fullbayesmanecgoodfits, echo = TRUE, results = "hide", cache = TRUE, dependson = "fullbayesmanec"}
## lapply(manecfit, check_chains)
## lapply(manecfit, check_priors)
cleaned_fits <- purrr::map(manecfit, function(x) {
  bad_fits <- rhat(x)$failed
  out_fit <- x
  if (length(bad_fits) > 0) {
    out_fit <- bayesnec::amend(x, drop = bad_fits)
  }
  out_fit
  # note for the decline model set there are no fits with bad rhat values for this example.
})
```

To facilitate comparison across the herbicides, we create a collated table of model weights by extracting the`$mod_stats` element from each herbicide's `bayesmanecfit`, again using \pkg{purrr}:

```{r weights, echo=TRUE,  dependson="fullbayesmanecgoodfits"}
library(tidyr)
modtab <- purrr::map_dfr(cleaned_fits, function(x) {
  x$mod_stats %>%
    dplyr::select(model, wi) %>%
    dplyr::mutate(wi = round(wi, 3))}, .id = "herbicide") %>%
  tidyr::pivot_wider(names_from = herbicide, values_from = wi)
```

This collated table of model weights shows that the best fitting models vary substantially across the C-R curves for the seven herbicides (\autoref{tab:weightsTab}). Few herbicides showed any weight for the *NEC* threshold models, with the exception of ametryn which had some, albeit limited, support. The weights for the various *ECx* models varied substantially, with at least some support for more than one model in all cases. This shows clearly the value of the model averaging approach adopted in \pkg{bayesnec}, which effectively accommodates this model uncertainty by seamlessly providing weighted model averaged inferences. Note that for all herbicides there were some models to did not fit successfully using the default \pkg{bayesnec} settings. While it should be possible to obtain valid fits for these few failed models using custom priors and/or initial values, the fact that there are already a large number of well fitting models in the model set for each herbicide suggests this would be unlikely to have any impact on inference, and here we proceed only with the currently valid fits. 

```{r weightsTab, echo=FALSE}
knitr::kable(modtab, caption="Fitted valid models and their relative pseudo-BMA weights for C-R curves for the effects seven herbicides on maximum effective quantum yield ($\\Delta F / Fm'$) of symbiotic dinoflagellates of the coral \\textit{Seriatopora hystrix}.")
```


We use the \pkg{bayesnec} `autoplot` , together with \pkg{ggpubr} to make a panel plot of the weighted model averaged predicted curves for all seven herbicides (\autoref{fig:fullbayesmanecplot}).

```{r fullbayesmanecpreplot, echo = TRUE, results = "hide", cache = FALSE}
all_plots <- lapply(cleaned_fits, function(x) {
  autoplot(x) +
  theme(axis.title.x = element_blank(),
         axis.title.y = element_blank(),
         strip.background = element_blank(),
         strip.text.x = element_blank()) +
    ggtitle("")})
figure <- ggpubr::ggarrange(plotlist = all_plots, nrow = 4, ncol = 2, labels = names(all_plots),
  font.label = list(color = "black", size = 12, face = "plain"), align = "hv")
```

```{r fullbayesmanecplot, echo = FALSE, fig.width = 6, fig.height = 8, fig.cap = "Full model averaged bayesmanecfits to seven phototoxicity datasets, showing estimated no effect concentrations. Data are the maximum effective quantum yield ($\\Delta F / Fm'$) of symbiotic dinoflagellates (in hospite) in \\textit{Seriatopora hystrix} exposed to elevated Irgarol 1051, ametryn, diuron, hexazinone, atrazine, simazine, or tebuthiuron (range 0.3 to 1000 ug per L) for 10 h. N(SEC) values presented are model averaged posterior densities of the NEC parameter obtained from all fitted \\texttt{NEC} models, and the NSEC values estimated from all smooth \\texttt{ECx} models. Only the \\texttt{decline} model set was used (ie. hormesis models were excluded)."}
ggpubr::annotate_figure(
  figure, left = ggpubr::text_grob(expression(""*Delta*"F"/"F m'"), rot = 90),
  bottom = ggpubr::text_grob(expression("Concentration "~"("*mu*"g/L)")))
```

Across the seven herbicides, they `bayesmanecfit` model averaged fits model the input data very well, with predictions generally very confident (\autoref{fig:fullbayesmanecplot}). The slight uncertainty in the appropriate model form for the ametryn dataset is evident in the weighted average predicted values as a broader confidence band at the estimated position of the NEC threshold point (\autoref{fig:fullbayesmanecplot}). 

The values presented on the plot in \autoref{fig:fullbayesmanecplot} as N(S)EC are model averaged posterior densities of the *NEC* parameter obtained from all fitted **nec** models, and the *NSEC* values estimated from all smooth **ecx** models. These values are the \pkg{bayesnec} estimates for the no-(significant)-effect concentration required for the integration of this toxicity data into the relevant regulatory framework in Australia, the Australian and New Zealand Water Quality Guidelines [@anzg]. While the recommendation that  *NEC* is the preferred toxicity estimate in this framework is well established [@Warne2015, @Warne2018c], use of the *NSEC* is relatively new [@Fisher2022] and yet to gain formal approval for use in the Australian setting, as discussed in more detail below. 

Finally, we also use the `compare_posterior` function to extract and plot the weighted averaged posterior samples for the N(S)EC toxicity values for all herbicides (\autoref{fig:necplots}). This shows clearly that irgarol, diuron and ametryn are the most toxic, and exhibit relatively similar toxicity, with their posterior densities substantially overlapping (\autoref{fig:necplots}). The herbicide tebuthiuron is the least toxic of these seven, followed by simazine, atrazine and finally haxinone, which exhibits intermediate toxicity (\autoref{fig:necplots}). `compare_posterior` also calculates the probability of difference in toxicity across the herbicides, which confirm the visual results and can be used to infer significant differences in toxicity (\autoref{tab:probdiffs}). 

```{r compare_posterior, echo = TRUE, cache = TRUE}
post_comp <- compare_posterior(cleaned_fits, comparison = "nec")
prob_diff <- post_comp$prob_diff %>% 
  separate(col = comparison, into = c("herbicide", "columns")) %>% 
  pivot_wider(names_from = columns, values_from = prob)
```

```{r necplots,  echo = FALSE, fig.width = 6, fig.height = 4, fig.cap = "Posterior distributions for N(S)EC toxicity estimates for the effect of seven herbicides on maximum effective quantum yield ($\\Delta F / Fm'$) of symbiotic dinoflagellates of the coral \\textit{Seriatopora hystrix}. Shown are medians with 80\\%  uncertainty intervals."}
post_comp$posterior_data %>% 
  mutate(conc=exp(value)) %>% 
ggplot(mapping = aes(x = conc)) + 
  geom_density(mapping = aes(group = model, colour = model, fill = model),
               alpha = 0.3) +
  xlab(expression("Concentration "~"("*mu*"g/L)")) +
  scale_x_continuous(trans = 'log', 
                     breaks = c(0.3, 1, 3, 10, 30),
                     labels = c(0.3, 1, 3, 10, 30))  +
  theme_classic()
```

```{r probdiffs, echo=FALSE}
knitr::kable(prob_diff, caption="Probability of differences in no-effect toxicity for seven herbicides. Values are based on the proportional overlap in predicted posterior probability density of the N(S)EC estimates.")
```

\newpage

# Discussion

In order to be accessible to a broad community of varying statistical capabilities, we have simplified fitting a \pkg{bayesnec} model as much as possible, whilst retaining the ability to modify a wide range of arguments as necessary. Where possible we have tried to set default values to align with those in \pkg{brms}. Wherever we deviate, this is generally towards being more conservative and/or we have clearly explained our reasoning. Specific examples include: 1) `iter`, which we increased from the \pkg{brms} default of 2,000 to 10,000 as we found that a higher number of iterations are generally required for these non-linear models; and 2) the use of `pointwise = TRUE` (where possible) and `sample_prior = "yes"` to avoid excessive R crashes when used in the Windows operating system and allow the use of the `hypothesis` function respectively. We welcome constructive criticism of our selections and users must expect that default settings may change accordingly in later releases. We encourage users to modify these default values themselves whenever appropriate.

We have made considerable effort to ensure that \pkg{bayesnec} makes a sensible prediction for the appropriate family, constructs appropriate weakly informative priors, and generates sensible initial values. However, this is a difficult task across such a broad range of non-linear models, and across the potential range of ecotoxicological data that may be used. The user must interrogate their model fits using the wide array of helper functions, and use their own judgement regarding the appropriateness of model inferences for their own application. Of particular importance are examination of model fit statistics through the `summary` and `rhat` methods, visual inspection of all model fits in `bayesmanecfit` objects (via `plot(..., all_models = TRUE)` and `check_chains(..., all_models = TRUE)`) and an assessment of the posterior versus prior probability densities to ensure default priors are appropriate (using `check_priors`).

The model averaging approach implemented in \pkg{bayesnec} is widely used in a range of settings [in ecology for example, see @Dormann2018 for a thorough review]. However, model averaging is relatively new to ecotoxicology [but see, for example, @Shao2014; @Thorley2018; @fox2020; @Wheeler2009]. In \pkg{bayesnec} we have implemented a broad range of potential models, and the default behaviour is to fit them all (if appropriate for the natural range of the response). More research is required to understand how model-set selection influences model inference. While some studies suggest using a broad range of models may be optimal [@Wheeler2009], others indicate that including multiple models of similar shape may overweight the representation of that shape in model averaged predictions [@fox2020]. In addition, it is important to understand that when models are added or removed from the model-set, this can sometimes have a substantial influence on model predictions (potentially changing estimated *EC~x~* values, for example). As the model-set in \pkg{bayesnec} may change through time it is important to keep a record of the models that were actually fitted in a given analysis, in the event it is necessary to reproduce a set of results. A potentially better strategy is to build a docker (https://docs.docker.com/get-docker/) container, an approach representing one strategy towards overcoming the reproducibility crisis [@Baker2016]. Considerations of analytical reproducibility are particularly relevant to C-R modelling, where the model outcomes can often have far reaching management implications.

## Model suitability for \textit{NEC} and \textit{EC\textsubscript{x}} estimation {short-title="Model suitability for NEC and ECx estimation" #modsuit}

In principle all models provide an estimate for the No-Effect-Concentration (*NEC*). As seen above, for model strings with **nec** as a prefix, the *NEC* is directly estimated as parameter $\eta = \text{NEC}$ in the model, as per [@Fox2010]. On the other hand, models strings with **ecx** as a prefix are continuous curve models with no threshold, typically used for extracting *EC~x~* values from concentration-response data. In this instance, the *NEC* reported is actually the No-Significant-Effect-Concentration (*NSEC*, see details in @Fisher2022), defined as the concentration at which there is a user supplied certainty (based on the Bayesian posterior estimate) that the response falls below the estimated value of the upper asymptote ($\tau = \text{top}$) of the response (i.e. the response value is significantly lower than that expected in the case of no exposure). The default value for this *NSEC* proportion is 0.01, which corresponds to an alpha value (Type-I error rate) of 0.01 for a one-sided test of significance. We currently recommend only using the `"nec"` model set for estimation of *NEC* values, as the *NSEC* concept is still under peer-review and yet to be accepted within regulatory contexts. Both *NEC* and *NSEC* can be calculated from fitted models using the functions `nec` and `nsec`.

*EC~x~* estimates can be equally obtained from both `"nec"` and `"ecx"` models. *EC~x~* estimates will usually be lower (more conservative) for `"ecx"` models fitted to the same data as `"nec"` models. There is ambiguity in the definition of *EC~x~* estimates from hormesis models---these allow an initial increase in the response [see @Mattson2008] and include models with the string **horme** in their name---as well as those that have no natural lower bound on the scale of the response (models with the string **lin** in their name, in the case of Gaussian response data). For this reason the `ecx` function has arguments `hormesis_def` and `type`, both character vectors indicating the desired behaviour. For `hormesis_def = "max"`, *EC~x~* values are calculated as a decline from the maximum estimates (i.e., the peak at $\eta = \text{NEC}$); and `hormesis_def = "control"` (the default) indicates that *EC~x~* values should be calculated relative to the control, which is assumed to be the lowest observed concentration. For `type = "relative"` *EC~x~* is calculated as the percentage decrease from the maximum predicted value of the response ($\tau = \text{top}$) to the minimum predicted value of the response (i.e., *relative* to the observed data). For `type = "absolute"` (the default) *EC~x~* is calculated as the percentage decrease from the maximum value of the response ($\tau = \text{top}$) to 0 (or $\delta = \text{bottom}$ for models with that parameter). For `type = "direct"`, a direct interpolation of the response on the predictor is obtained.

## Model suitability for response types

Models that have an exponential decay (most models with parameter $\beta = \text{beta}$) with no $\delta = \text{bottom}$ parameter are 0-bounded and are not suitable for the Gaussian family, or any family modelled using a `"logit"` or `"log"` link because they cannot generate predictions of negative response values. Conversely, models with a linear decay (containing the string **lin** in their name) are not suitable for modelling families that are 0-bounded (Gamma, Poisson, Negative Binomial, Beta, Binomial, Beta-Binomial) using an `"identity"` link. These restrictions do not need to be controlled by the user, as a call to `bnec` with `models = "all"` in the formula will simply exclude inappropriate models, albeit with a message.

Strictly speaking, models with a linear hormesis increase are not suitable for modelling responses that are 0, 1-bounded (Binomial-, Beta- and Beta-Binomial-distributed), however they are currently allowed in \pkg{bayesnec}, with a reasonable fit achieved through a combination of the appropriate distribution being applied to the response, and \pkg{bayesnec}'s `make_inits` function which ensures initial values passed to \pkg{brms} yield response values within the range of the user-supplied response data.

# Future directions

The \pkg{bayesnec} package is a work in progress, and we welcome suggestions and feedback that will improve the package performance and function. Our goal is to make \pkg{bayesnec} as user friendly as possible, and capable of dealing with most real world C-R modelling applications in the hope that Bayesian statistics will become more widely used in applied risk assessment. Please submit requests through the package [Issues](https://github.com/open-AIMS/bayesnec/issues) on GitHub. Some suggested future enhancements include:

 - The addition of other custom families, such as the Tweedie distribution and ordered beta model. Currently \pkg{bayesnec} implements adjustments away from 0 (Gamma, Beta) or 1 (Beta) as a strategy for allowing modelling with these types of data using the closest most convenient statistical distribution. 
 There are no readily available distributions able to model data that includes 0 and 1 on the continuous scale in \pkg{brms} and \pkg{bayesnec} currently does 0 and 1 adjustments followed by modelling using a Beta distribution. The ordered beta model has been suggested as a better method for modelling continuous data with lower an upper bounds (see @Kubinec) that could be readily implemented in the \pkg{brms} customs families framework.
 For data that are 0 to $\infty$ on the continuous scale the Tweedie distribution may prove a much better option than the current zero-bounded Gamma, and has been used extensively in fisheries research for biomass data [@Shono2008]. As this family is not currently available in \pkg{brms} this would also need to be implemented as a custom family, which for the Tweedie is not trivial.

 - A hypothesis method for testing against toxicity thresholds. The \pkg{brms} package includes a `hypothesis` function that allows for testing parameter estimates against specified criteria. This is used in \pkg{bayesnec} in the `check_prior` function, which is a wrapper that examines the deviation of each parameter in the given model relative to 0 as a means of generating posterior and prior probability density plots for comparison. However, an additional wrapper function could be developed that allows toxicity to be assessed, as measured through *NEC*, or *EC~x~* for example, against a required pre-defined threshold. Such a feature may be useful where toxicity testing is used as a trigger in risk management [for example, using whole-effluent-toxicity (WET) testing, @Karman2019].

# Acknowledgements

The development of \pkg{bayesnec} was supported by an AIMS internal grant. Usage, testing and functionality of both the \pkg{jagsNEC} and \pkg{bayesnec} packages were substantially aided through input from Joost van Dam, Andrew Negri, Florita Flores, Heidi Luter, Marie Thomas and Mikaela Nordborg. Florita Flores and Murray Logan provided valuable comments on the manuscript text. Ron Jones provided technical computing support. 

# References

```{r sessioninfo, eval=TRUE, include=FALSE}
sessionInfo()
```
